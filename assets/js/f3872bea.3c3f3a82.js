"use strict";(self.webpackChunkfreewili_docs=self.webpackChunkfreewili_docs||[]).push([[6903],{6502:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>s,contentTitle:()=>n,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>m});var a=t(4848),r=t(8453);const o={title:"FPGA Programming for iCE40 - Automatic and On-Demand Configuration",description:"Learn how the iCE40 FPGA in FREE-WILi is automatically programmed at power up with a default configuration. Explore how it can be reprogrammed anytime using the SPI Slave Configuration Interface and stored bit files from the RP2040 or USB.",keywords:["iCE40 FPGA Programming","FPGA SRAM Configuration","RP2040 FPGA Reprogramming","SPI Slave Configuration Interface","Intrepid IO App FPGA Management","FPGA Bit Files Storage"],sidebar_position:1,sidebar_label:"FPGA Programming"},n="FPGA Programming",l={id:"hardware-low-level-details/ice40-fpga/fpga-programming",title:"FPGA Programming for iCE40 - Automatic and On-Demand Configuration",description:"Learn how the iCE40 FPGA in FREE-WILi is automatically programmed at power up with a default configuration. Explore how it can be reprogrammed anytime using the SPI Slave Configuration Interface and stored bit files from the RP2040 or USB.",source:"@site/docs/hardware-low-level-details/ice40-fpga/fpga-programming.md",sourceDirName:"hardware-low-level-details/ice40-fpga",slug:"/hardware-low-level-details/ice40-fpga/fpga-programming",permalink:"/hardware-low-level-details/ice40-fpga/fpga-programming",draft:!1,unlisted:!1,editUrl:"https://github.com/freewili/FreeWili_WebDocs/blob/main/docs/hardware-low-level-details/ice40-fpga/fpga-programming.md",tags:[],version:"current",lastUpdatedAt:1724134738e3,sidebarPosition:1,frontMatter:{title:"FPGA Programming for iCE40 - Automatic and On-Demand Configuration",description:"Learn how the iCE40 FPGA in FREE-WILi is automatically programmed at power up with a default configuration. Explore how it can be reprogrammed anytime using the SPI Slave Configuration Interface and stored bit files from the RP2040 or USB.",keywords:["iCE40 FPGA Programming","FPGA SRAM Configuration","RP2040 FPGA Reprogramming","SPI Slave Configuration Interface","Intrepid IO App FPGA Management","FPGA Bit Files Storage"],sidebar_position:1,sidebar_label:"FPGA Programming"},sidebar:"tutorialSidebar",previous:{title:"iCE40 FPGA",permalink:"/hardware-low-level-details/ice40-fpga/"},next:{title:"FPGA Clock",permalink:"/hardware-low-level-details/ice40-fpga/fpga-clock"}},s={},m=[];function d(e){const i={h1:"h1",header:"header",p:"p",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"fpga-programming",children:"FPGA Programming"})}),"\n",(0,a.jsx)(i.p,{children:"The ice40 FPGA is a SRAM configured FPGA that is programmed automatically at power up."}),"\n",(0,a.jsx)(i.p,{children:"By default the ice40 reads a default configuration from its OTP memory. This default image allows basic pass through configuration  of the RP2040 gpio to the IO drivers."}),"\n",(0,a.jsx)(i.p,{children:'Because of the SRAM configuration, the FPGA can be reprogrammed unlimted times at anytime by the RP2040 chip. To do this the RP2040 uses the the FPGA DONE, FPGA RESET and SPI interface from the RP2040. The ice40 documentation calls this the "SPI Slave Configuration Interface". This method of programming is described in the Lattice ICE40 document "iCE40 Programming and Configuration" with document number FPGA-TN-02001.'}),"\n",(0,a.jsx)(i.p,{children:"When reprogramming the FPGA the bit file would be fed from the RP2040. An obvious place to store the bit file is RP2040 flash as a const byte array."}),"\n",(0,a.jsx)(i.p,{children:"The Intrepid IO app can store multiple FPGA bit files in its file system and load them on command or at startup. It can also load them directly from USB."})]})}function c(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>n,x:()=>l});var a=t(6540);const r={},o=a.createContext(r);function n(e){const i=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:n(e.components),a.createElement(o.Provider,{value:i},e.children)}}}]);