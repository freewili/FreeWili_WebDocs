"use strict";(self.webpackChunkfreewili_docs=self.webpackChunkfreewili_docs||[]).push([[9016],{481:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var a=i(4848),n=i(8453);const s={sidebar_position:4},r="FPGA Default Application",l={id:"hardware-low-level-details/ice40-fpga/fpga-default-application",title:"FPGA Default Application",description:"FPGA APP",source:"@site/docs/hardware-low-level-details/ice40-fpga/fpga-default-application.md",sourceDirName:"hardware-low-level-details/ice40-fpga",slug:"/hardware-low-level-details/ice40-fpga/fpga-default-application",permalink:"/hardware-low-level-details/ice40-fpga/fpga-default-application",draft:!1,unlisted:!1,editUrl:"https://github.com/freewili/FreeWili_WebDocs/blob/main/docs/hardware-low-level-details/ice40-fpga/fpga-default-application.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"FPGA Connections",permalink:"/hardware-low-level-details/ice40-fpga/fpga-connections"},next:{title:"FREE-WILi Firmware Update",permalink:"/freewili-firmware-update"}},o={},d=[];function c(e){const t={a:"a",h1:"h1",img:"img",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"fpga-default-application",children:"FPGA Default Application"}),"\n",(0,a.jsx)("div",{class:"text--center",children:(0,a.jsxs)("figure",{children:[(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"FPGA APP",src:i(8807).A+"",title:"FPGA APP",width:"1811",height:"952"})}),(0,a.jsx)("figcaption",{})]})}),"\n",(0,a.jsx)(t.p,{children:"The default FPGA application is a simple design that transforms the FREE-WILi into a sigrok-compatible logic analyzer."}),"\n",(0,a.jsxs)(t.p,{children:["The design features an IO buffer that can set the directions of the SPI and UART pins as well as GPIO_26 and GPIO27. To enable this programming, the IO_CONFIG_ENABLE pin must be asserted - this allows the FPGA's SPI-Slave to assume control of the SPI interface with the main RP2040 as the master. The pin direction defaults are as specified in ",(0,a.jsx)(t.a,{href:"/gpio/",children:"GPIO"}),". Please note that the pin directionality is also dependent on the sn74lxc1t45 hardware IO buffers between the FPGA and breakout pins."]}),"\n",(0,a.jsxs)(t.p,{children:["For the logic analyzer, the FPGA samples the SPI pins at the clock frequency provided by the main RP2040 - this design expects a frequency of 31.25 MHz. The samples are encoded via Run-Length Encoding and, once the FPGA is initiated by sigrok via FTDI, stored in a 32 kB FIFO built using the iCE40's on-chip SPRAM. Finally, these samples are sent via the FT1248 4-wire communication protocol to USB where sigrok can collect them. The libsigrok fork where the FREE-WILi hardware driver was developed can be found at ",(0,a.jsx)(t.a,{href:"https://github.com/Ytuf/libsigrok-fwili",children:"libsigrok-fwili"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"The translation from the sigrok channel name to the corresponding pin for SPI protocol is detailed below."}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"sigrok channel name"}),(0,a.jsx)(t.th,{children:"SPI"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"4"}),(0,a.jsx)(t.td,{children:"CS"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"3"}),(0,a.jsx)(t.td,{children:"SCLK"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"2"}),(0,a.jsx)(t.td,{children:"MOSI"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"1"}),(0,a.jsx)(t.td,{children:"MISO"})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8807:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/fpga_default_app-cb2534c81a384e25f7359dbc6f41df50.png"},8453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>l});var a=i(6540);const n={},s=a.createContext(n);function r(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);